[{"C:\\Users\\marcos\\Documents\\GitHub\\math\\src\\index.jsx":"1","C:\\Users\\marcos\\Documents\\GitHub\\math\\src\\App.jsx":"2"},{"size":402,"mtime":1607107158488,"results":"3","hashOfConfig":"4"},{"size":4264,"mtime":1607487587547,"results":"5","hashOfConfig":"4"},{"filePath":"6","messages":"7","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"8"},"1o7utao",{"filePath":"9","messages":"10","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"11"},"C:\\Users\\marcos\\Documents\\GitHub\\math\\src\\index.jsx",[],["12","13"],"C:\\Users\\marcos\\Documents\\GitHub\\math\\src\\App.jsx",["14","15"],"import \"./index.css\";\r\nimport React, { Component } from 'react';\r\nimport * as tf from '@tensorflow/tfjs';\r\n\r\nclass App extends Component {\r\n\r\n  constructor(props){\r\n    super(props);\r\n    this.state= {\r\n      lastPosition:null,\r\n      drawing:false,\r\n      prediction:null,\r\n    };\r\n    this.canvasRef = React.createRef();\r\n    this.clear = this.clear.bind(this);\r\n    this.predict = this.predict.bind(this);\r\n    this.moving = this.moving.bind(this);\r\n    this.split = this.split.bind(this);\r\n    this.rescaled = this.rescaled.bind(this);\r\n  }\r\n\r\n  handleEvent = (event) => {\r\n    if (event.type === \"mousedown\")\r\n      this.setState({ drawing: true});\r\n    else\r\n      this.setState({ drawing: false});\r\n   }\r\n\r\n  clear() {\r\n    const canvas = this.canvasRef.current;\r\n    const ctx = canvas.getContext(\"2d\");\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n    ctx.fillStyle = \"#FFFF\";\r\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n  }\r\n\r\n  async split(n){\r\n    const canvas = this.canvasRef.current;\r\n    const ctx = canvas.getContext(\"2d\");\r\n\r\n    const resizedCanvas = document.createElement(\"canvas\");\r\n    const resizedContext = resizedCanvas.getContext(\"2d\");\r\n    resizedCanvas.width = await canvas.width/n;\r\n    resizedCanvas.height = 400;\r\n\r\n    const splits = [];\r\n    const img = new Image(600/n,400);\r\n    for(var i = 0; i < n; i++){\r\n      const Image_data = await ctx.getImageData(i*canvas.width/n, 0, 600/n, 400);\r\n      resizedContext.putImageData(Image_data,0,0);\r\n      img.src = resizedCanvas.toDataURL();\r\n      splits.push(img);\r\n    }\r\n    console.log(splits);\r\n\r\n    return splits; //returns an array of Elemets <img>\r\n  }\r\n\r\n  async rescaled(arr){\r\n    const rescaled = [];\r\n    const img = new Image(32,32);\r\n    const resizedCanvas = document.createElement(\"canvas\");\r\n    const resizedContext = resizedCanvas.getContext(\"2d\");\r\n    resizedCanvas.height = 32;\r\n    resizedCanvas.width = 32;\r\n\r\n    for(let i = 0; i < arr.length; i++){\r\n      resizedContext.drawImage(await arr[i], 0, 0, 32, 32);\r\n      img.src = resizedCanvas.toDataURL();\r\n\r\n      let downloadLink = document.createElement('a');\r\n      downloadLink.setAttribute('download', 'CanvasAsImage.png');\r\n  \r\n      await resizedCanvas.toBlob((blob) => {\r\n        let url = URL.createObjectURL(blob);\r\n        downloadLink.setAttribute('href', url);\r\n        downloadLink.click();\r\n      });\r\n\r\n\r\n      rescaled.push(img);\r\n    }\r\n    console.log(rescaled)\r\n    return rescaled;\r\n  }\r\n\r\n  async predict(){ \r\n    const model = await tf.loadLayersModel('https://storage.googleapis.com/mathsolvermodel/model.json');\r\n\r\n    const split_images = await this.split(1);\r\n    const resized_images = await this.rescaled(split_images);\r\n\r\n    var img = document.getElementsByClassName(\"t\");\r\n    console.log(resized_images);\r\n\r\n    const resized_grayscale_Tensor = tf.browser.fromPixels(resized_images[0]).mean(2).toFloat().expandDims(0).expandDims(-1);\r\n    const prediction = model.predict(resized_grayscale_Tensor);\r\n    const value = prediction.dataSync()\r\n\r\n    console.log(value);\r\n  }\r\n\r\n  moving(e) {\r\n    const canvas = this.canvasRef.current;\r\n    const ctx = canvas.getContext('2d');\r\n      var pos = {\r\n        x: e.clientX - canvas.getBoundingClientRect().left,\r\n        y: e.clientY - canvas.getBoundingClientRect().top\r\n      };\r\n    if (this.state.lastPosition !== null && this.state.drawing) {\r\n      ctx.lineWidth = 10;\r\n      ctx.lineCap = \"round\";\r\n      ctx.beginPath();\r\n      ctx.fillStyle = \"#000000\";\r\n      ctx.moveTo(this.state.lastPosition.x, this.state.lastPosition.y);\r\n      ctx.lineTo(pos.x, pos.y);\r\n      ctx.closePath();\r\n      ctx.stroke();\r\n    }\r\n    this.setState({lastPosition: pos});\r\n  }\r\n\r\n  render(){\r\n    return (\r\n      <div>\r\n        <h1>My Math Solver</h1>\r\n        <canvas ref={this.canvasRef} width={600} height={400} onMouseMove={e => this.moving(e)} onMouseUp={this.handleEvent} onMouseDown={this.handleEvent}> </canvas>\r\n        <div className=\"stuffs\">\r\n          <button onClick={this.clear}>Clear</button>\r\n          <button onClick={this.predict}>Predict</button>\r\n          <img className=\"t\"></img>\r\n        </div>\r\n        <h2>{this.state.prediction}</h2>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default App;\r\n",{"ruleId":"16","replacedBy":"17"},{"ruleId":"18","replacedBy":"19"},{"ruleId":"20","severity":1,"message":"21","line":93,"column":9,"nodeType":"22","messageId":"23","endLine":93,"endColumn":12},{"ruleId":"24","severity":1,"message":"25","line":131,"column":11,"nodeType":"26","endLine":131,"endColumn":30},"no-native-reassign",["27"],"no-negated-in-lhs",["28"],"no-unused-vars","'img' is assigned a value but never used.","Identifier","unusedVar","jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","JSXOpeningElement","no-global-assign","no-unsafe-negation"]